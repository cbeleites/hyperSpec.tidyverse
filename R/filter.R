#' filter or slice hyperSpec object
#'
#' `filter`ing based on extra data columns works smoothly,
#' but filtering on the spectra matrix needs some attention:
#' the filtering expression must return a logical vector with one value per spectrum,
#' see examples.
#'
#' @inheritParams dplyr::filter
#'
#' @return hyperSpec object with rows (spectra) matching the conditions (logical predicates) or the indices specified in `...`
#' @include unittest.R
#' @seealso [dplyr::filter()]
#' @importFrom dplyr filter
#' @importFrom hyperSpec chk.hy
#' @import magrittr
#' @export
#'
#' @examples
#' filter (flu, c < 0.2)
#' flu %>% filter (c < 0.2)
#'
#' ## filtering based on the spectra matrix:
#' # remove all spectra with NAs
#' tmp <- flu
#' tmp [[3:4,, 300 ~ 450]] <- NA
#' tmp [[6]] <- NA
#'
#' tmp %>% filter (!any_wl (is.na (spc)))
#' tmp %>% filter (all_wl (!is.na (spc))) # the same
#'
#' # remove spectra that contain only NAs:
#' tmp %>% filter (!all_wl (is.na (spc)))
#' tmp %>% filter (any_wl (!is.na (spc))) # the same
#'
#' # keep only spectra with minimum average intensity
#' chondro %>%
#'    filter (rowMeans (spc) > 500) %>%
#'    plotmap
filter.hyperSpec <- function(.data, ..., .preserve = FALSE) {

  .data@data <- filter (.data@data, ..., .preserve = .preserve)
  chk.hy(.data)

  .data
}

.test(filter.hyperSpec) <- function (){
  context("filter")

  test_that ("filtering extra data columns", {
    expect_equal(filter (flu, c > 0.3), flu [flu$c > 0.3]) # 0 row object

    # filter drops row names, so only equivalent, not equal:
    expect_equivalent(filter (flu, c > 0.2), flu [flu$c > 0.2])

    expect_equivalent(filter (chondro, clusters == "lacuna"),
                 chondro [chondro$clusters == "lacuna" & !is.na (chondro$clusters)]

    )
  })

  test_that ("filtering the spectra matrix", {
    expect_error (filter (flu, spc > 300))

    expect_equivalent(
      filter (flu, all_wl (spc > 100)),
      flu [all_wl (flu > 100)]
    )

    tmp <- flu
    tmp [[3:4,, 300 ~ 450]] <- NA
    tmp [[6]] <- NA

    expect_equivalent(
      filter (tmp, all_wl (! is.na (spc))),
      tmp [all_wl (! is.na (tmp))]
    )

    expect_equivalent(
      filter (tmp, !any_wl (is.na (spc))),
      tmp [all_wl (! is.na (tmp))]
    )

  })

  test_that("grouping and filter", {
    skip ("grouping not yet implemented")
  })
}


#' @inheritParams dplyr::slice
#' @rdname filter.hyperSpec
#' @importFrom dplyr slice
#' @export
#'
#' @examples
#' chondro %>% slice (1:3)
#' chondro %>% slice (800 : n())
#' chondro %>% slice (-10 : -n())

slice.hyperSpec <- function(.data, ..., .preserve = FALSE) {

  .data@data <- slice (.data@data, ..., .preserve = .preserve)
  chk.hy(.data)

  .data
}

.test(slice.hyperSpec) <- function (){
  context("slice")

  test_that ("simple slicing", {
    expect_equal(slice (flu, 1:3), flu [1:3])
    expect_equal(slice (flu, 0), flu [0])

    # slice drops row names, so only equivalent, not equal:
    expect_equivalent (slice (flu, 3 : n()), flu [3 : nrow (flu)])

    expect_equal(slice (flu, -3 : -n()), flu [-3 : -nrow (flu)])
  })

  test_that ("multiple index parameters", {
    expect_equivalent (slice (chondro, 1:3, n() - (0:3)),
                       chondro [c (1:3, nrow (chondro) - (0:3))]
    )
  })

  test_that("grouping and slice", {
    skip ("grouping not yet implemented")
  })
}

#slice_.hyperSpec <- slice.hyperSpec
